MODULE main
  VAR
    pc : 0..8;  -- program counter (single state var)
                -- 0: WHI    -- while (i < m)
                -- 1: WHJ    -- while (j < p)
                -- 2: RESET  -- k := 0; C[i,j] := 0
                -- 3: WHK    -- while (k < n)
                -- 4: MAC    -- C[i,j] += A[i,k] * B[k,j]
                -- 5: KPP    -- k++
                -- 6: JPP    -- j++
                -- 7: IPP    -- i++
                -- 8: RET    -- return / done

  -- Atomic propositions (derived from the integer pc; convenient for HyperLTL)

  ASSIGN
    init(pc) := 0;  -- start at WHI

    -- Canonical triple-loop shape (no stuttering here)
    next(pc) :=
      case
        pc = 0 : {1, 8};   -- if (i < m) -> WHJ; else -> RET
        pc = 1 : {2, 7};   -- if (j < p) -> RESET; else -> IPP
        pc = 2 : 3;        -- initialize inner dot-product, then WHK
        pc = 3 : {4, 6};   -- if (k < n) -> MAC; else -> JPP
        pc = 4 : 5;        -- one MAC step, then k++
        pc = 5 : 3;        -- re-check while(k < n)
        pc = 6 : 1;        -- next column, re-check while(j < p)
        pc = 7 : 0;        -- next row, re-check while(i < m)
        pc = 8 : 8;        -- done (absorbing)
      esac;
