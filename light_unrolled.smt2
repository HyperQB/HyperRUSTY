; SMT-LIBv2 description generated by Yosys 0.56+101 (git sha1 dbb977aa8, aarch64-apple-darwin23.5-clang++ 18.1.8 -fPIC -O3)
; yosys-smt2-stdt
; yosys-smt2-module light
(declare-datatype |light_s| ((|light_mk|
  (|light_is| Bool)
  (|clock| Bool) ; \clock
  (|light_out| (_ BitVec 1)) ; \light_out
  (|state123| (_ BitVec 2)) ; \state123
  (|up| Bool) ; \up
)))
; yosys-smt2-input clock 1
; yosys-smt2-wire clock 1
; yosys-smt2-clock clock posedge
; yosys-smt2-witness {"offset": 0, "path": ["\\clock"], "smtname": "clock", "smtoffset": 0, "type": "posedge", "width": 1}
; yosys-smt2-witness {"offset": 0, "path": ["\\clock"], "smtname": "clock", "smtoffset": 0, "type": "input", "width": 1}
(define-fun |light_n clock| ((state |light_s|)) Bool (|clock| state))
; yosys-smt2-witness {"offset": 0, "path": ["\\light_out"], "smtname": 1, "smtoffset": 0, "type": "reg", "width": 1}
; yosys-smt2-output light_out 1
; yosys-smt2-register light_out 1
; yosys-smt2-wire light_out 1
(define-fun |light_n light_out| ((state |light_s|)) Bool (= ((_ extract 0 0) (|light_out| state)) #b1))
; yosys-smt2-witness {"offset": 0, "path": ["\\state123"], "smtname": 2, "smtoffset": 0, "type": "reg", "width": 2}
; yosys-smt2-register state123 2
; yosys-smt2-wire state123 2
(define-fun |light_n state123| ((state |light_s|)) (_ BitVec 2) (|state123| state))
; yosys-smt2-input up 1
; yosys-smt2-wire up 1
; yosys-smt2-witness {"offset": 0, "path": ["\\up"], "smtname": "up", "smtoffset": 0, "type": "input", "width": 1}
(define-fun |light_n up| ((state |light_s|)) Bool (|up| state))
(define-fun |light#4| ((state |light_s|)) (_ BitVec 2) (ite (|up| state) #b01 #b10)) ; $procmux$8_Y
(define-fun |light#5| ((state |light_s|)) Bool (= (|state123| state) #b10)) ; $procmux$5_CMP
(define-fun |light#6| ((state |light_s|)) Bool (= (|state123| state) #b01)) ; $procmux$6_CMP
(define-fun |light#7| ((state |light_s|)) Bool (not (or  (= ((_ extract 0 0) (|state123| state)) #b1) (= ((_ extract 1 1) (|state123| state)) #b1)))) ; $procmux$10_CMP
(define-fun |light#8| ((state |light_s|)) (_ BitVec 2) (ite (|light#7| state) (|light#4| state) (ite (|light#6| state) #b00 (ite (|light#5| state) #b00 (|state123| state))))) ; $0\state123[1:0]
(define-fun |light#9| ((state |light_s|)) Bool (= (|state123| state) #b10)) ; $procmux$12_CMP
(define-fun |light#10| ((state |light_s|)) Bool (= (|state123| state) #b01)) ; $procmux$13_CMP
(define-fun |light#11| ((state |light_s|)) Bool (not (or  (= ((_ extract 0 0) (|state123| state)) #b1) (= ((_ extract 1 1) (|state123| state)) #b1)))) ; $procmux$16_CMP
(define-fun |light#12| ((state |light_s|)) (_ BitVec 1) (ite (|light#11| state) #b1 (ite (|light#10| state) #b0 (ite (|light#9| state) #b0 (|light_out| state))))) ; $0\l[0:0]
(define-fun |light_a| ((state |light_s|)) Bool true)
(define-fun |light_u| ((state |light_s|)) Bool true)
(define-fun |light_i| ((state |light_s|)) Bool (and
  (= (= ((_ extract 0 0) (|light_out| state)) #b1) false) ; light_out
  (= (|state123| state) #b00) ; state123
))
(define-fun |light_h| ((state |light_s|)) Bool true)
(define-fun |light_t| ((state |light_s|) (next_state |light_s|)) Bool (and
  (= (|light#8| state) (|state123| next_state)) ; $procdff$18 \state123
  (= (|light#12| state) (|light_out| next_state)) ; $procdff$17 \light_out
)) ; end of module light
; yosys-smt2-topmod light
; end of yosys output

; Probes for variable clock
(declare-const |probe_clock_q_0| Bool)
(declare-const |probe_clock_q_1| Bool)
(declare-const |probe_clock_q_2| Bool)

; Probes for variable light_out
(declare-const |probe_light_out_q_0| Bool)
(declare-const |probe_light_out_q_1| Bool)
(declare-const |probe_light_out_q_2| Bool)

; Probes for variable state123
(declare-const |probe_state123_q_0| (_ BitVec 2))
(declare-const |probe_state123_q_1| (_ BitVec 2))
(declare-const |probe_state123_q_2| (_ BitVec 2))

; Probes for variable up
(declare-const |probe_up_q_0| Bool)
(declare-const |probe_up_q_1| Bool)
(declare-const |probe_up_q_2| Bool)

; Unrolled states
(declare-const |s_q_0| |light_s|)
(declare-const |s_q_1| |light_s|)
(declare-const |s_q_2| |light_s|)

; Initial and Next-state constraints
(assert (and (|light_i| |s_q_0|) (|light_t| s_q_0 s_q_1) (|light_t| s_q_1 s_q_2) (= |probe_clock_q_0| (|light_n clock| s_q_0)) (= |probe_clock_q_1| (|light_n clock| s_q_1)) (= |probe_clock_q_2| (|light_n clock| s_q_2)) (= |probe_light_out_q_0| (|light_n light_out| s_q_0)) (= |probe_light_out_q_1| (|light_n light_out| s_q_1)) (= |probe_light_out_q_2| (|light_n light_out| s_q_2)) (= |probe_state123_q_0| (|light_n state123| s_q_0)) (= |probe_state123_q_1| (|light_n state123| s_q_1)) (= |probe_state123_q_2| (|light_n state123| s_q_2)) (= |probe_up_q_0| (|light_n up| s_q_0)) (= |probe_up_q_1| (|light_n up| s_q_1)) (= |probe_up_q_2| (|light_n up| s_q_2)) ))
; End of unrolling constraints
